(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{408:function(t,c,r){"use strict";r.r(c);var a=r(1),e=Object(a.a)({},(function(){var t=this,c=t._self._c;return c("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[c("div",{attrs:{align:"center"}},[c("h1",[t._v("TreeMap 源码解析")])]),t._v(" "),c("blockquote",[c("p",[t._v("深入的学习源码，有助于我们在平常的作业开发过程中更好的使用集合，同时也是知道什么样的集合以及数据结构，在何种场合下使用最为方便")])]),t._v(" "),c("p",[c("img",{attrs:{src:"https://img-blog.csdnimg.cn/9f8442c00bd940b6b169431478fe14d7.png#pic_center",alt:"在这里插入图片描述"}})]),t._v(" "),c("p",[c("img",{attrs:{src:"https://img-blog.csdnimg.cn/8fec8cccbca648688732c94e2246da43.png#pic_center",alt:"在这里插入图片描述"}})]),t._v(" "),c("blockquote",[c("p",[t._v("TreeMap 的核心在于平衡二叉树 + 红黑树")])]),t._v(" "),c("h2",{attrs:{id:"重要属性"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#重要属性"}},[t._v("#")]),t._v(" 重要属性")]),t._v(" "),c("hr"),t._v(" "),c("ul",[c("li",[c("code",[t._v("Comparator")]),t._v(" 表示外部比较器，因为平衡二叉树需要比较大小，所以必须具有外部/内部 比较器")]),t._v(" "),c("li",[c("code",[t._v("Entry<K,V> root")]),t._v(" 表示二叉树的 root 节点")])]),t._v(" "),c("h2",{attrs:{id:"构造器解析"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#构造器解析"}},[t._v("#")]),t._v(" 构造器解析")]),t._v(" "),c("hr"),t._v(" "),c("p",[c("img",{attrs:{src:"https://img-blog.csdnimg.cn/2790a10793c74e7ba934011fc7bda4e1.png#pic_center",alt:"在这里插入图片描述"}})]),t._v(" "),c("h2",{attrs:{id:"put-函数核心解析"}},[c("a",{staticClass:"header-anchor",attrs:{href:"#put-函数核心解析"}},[t._v("#")]),t._v(" put 函数核心解析")]),t._v(" "),c("hr"),t._v(" "),c("p",[c("img",{attrs:{src:"https://img-blog.csdnimg.cn/ee0a9beed1474bf6b56cc5c84d01dd11.png#pic_center",alt:"在这里插入图片描述"}})]),t._v(" "),c("ul",[c("li",[t._v("上述的原理 其实就是平衡二叉树的 实现原理。")])])])}),[],!1,null,null,null);c.default=e.exports}}]);