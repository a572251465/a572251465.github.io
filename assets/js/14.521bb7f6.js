(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{428:function(t,s,a){"use strict";a.r(s);var n=a(1),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{attrs:{align:"center"}},[s("h1",[t._v("事件循环")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/4698b74da7724df3b718d73c7ca7d2e5.png#pic_center",alt:"事件循环"}})]),t._v(" "),s("h2",{attrs:{id:"疑问"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#疑问"}},[t._v("#")]),t._v(" 疑问")]),t._v(" "),s("blockquote",[s("p",[t._v("众所周知浏览器的主线程是单线程的，在正真执行过程中是如何处理代码执行/ dom变化/ 渲染等情况的呢")])]),t._v(" "),s("ul",[s("li",[t._v("通过上述实例中可以看到，我们触发的任务都会被封装成功一个个宏任务添加到消息队列中")]),t._v(" "),s("li",[t._v("只不过是事件循环机制会从队列中拿到一个个任务执行")]),t._v(" "),s("li",[t._v("但是针对延时任务，我们会有单独的延时队列，在触发延时功能的时候，会识别延时任务的开始时间/ 延时时间/ 结束时间等，将他们放置到延时队列中")]),t._v(" "),s("li",[t._v("每次执行事件循环的时候都会检查延迟队列中的任务是否到期，如果到期了将其添加到消息队列中")]),t._v(" "),s("li",[t._v("通过以上情况可以得知：延迟队列的执行是不精准的。队列之前的任务执行时间会耽误延时任务的执行。例如：")])]),t._v(" "),s("div",{staticClass:"language-javascript line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'测试结果'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100000000000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br")])]),s("ul",[s("li"),t._v(" "),s("li",[t._v("通过上述的实例可以得出，打印逻辑并不是立刻执行，而是等到同步执行结束后才会执行")]),t._v(" "),s("li",[t._v("那如何保证任务的优先级以及准确性呢？？？\n"),s("ul",[s("li",[t._v("事件循环中引入了"),s("code",[t._v("微任务")]),t._v("的概念。")]),t._v(" "),s("li",[t._v("每个宏任务的执行都会创建自己的微任务队列，将触发的微任务添加到队列中")]),t._v(" "),s("li",[t._v("微任务会在渲染之前都执行结束")])])])])])}),[],!1,null,null,null);s.default=e.exports}}]);